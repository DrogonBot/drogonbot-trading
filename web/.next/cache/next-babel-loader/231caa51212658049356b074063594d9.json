{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport 'moment/locale/pt-br';\nimport moment from 'moment';\nimport { appEnv, AvailableLanguages } from '../constants/Env.constant';\nexport class DateHelper {}\n\n_defineProperty(DateHelper, \"displayHumanDate\", date => {\n  switch (appEnv.language) {\n    case AvailableLanguages.ptBr:\n      return moment(date).locale(\"pt-br\").format(\"ddd, DD MMM YY\");\n\n    case AvailableLanguages.eng:\n      return moment(date).locale(\"en\").format(\"ddd, MMM Do YY\");\n\n    default:\n      return moment(date).locale(\"en\").format(\"ddd, MMM Do YY\");\n  }\n});\n\n_defineProperty(DateHelper, \"_analyzeDate\", (inputFormat, separator) => {\n  const splittedData = inputFormat.split(separator);\n  const dataComponentsPosition = {\n    month: {\n      index: 0,\n      characters: 0\n    },\n    year: {\n      index: 0,\n      characters: 0\n    },\n    day: {\n      index: 0,\n      characters: 0\n    }\n  }; // tslint:disable-next-line: forin\n\n  for (const index in splittedData) {\n    if (splittedData[index].includes(\"D\")) {\n      dataComponentsPosition.day.index = parseInt(index);\n      dataComponentsPosition.day.characters = splittedData[index].length;\n    }\n\n    if (splittedData[index].includes(\"M\")) {\n      dataComponentsPosition.month.index = parseInt(index);\n      dataComponentsPosition.month.characters = splittedData[index].length;\n    }\n\n    if (splittedData[index].includes(\"Y\")) {\n      dataComponentsPosition.year.index = parseInt(index);\n      dataComponentsPosition.year.characters = splittedData[index].length;\n    }\n  }\n\n  return dataComponentsPosition;\n});\n\n_defineProperty(DateHelper, \"parseDataToServerFormat\", (rawData, inputFormat, separator) => {\n  const splittedRawData = rawData.split(separator);\n\n  const analyzedInputFormat = DateHelper._analyzeDate(inputFormat, separator);\n\n  const month = splittedRawData[analyzedInputFormat.month.index];\n  const day = splittedRawData[analyzedInputFormat.day.index];\n  const year = splittedRawData[analyzedInputFormat.year.index]; // this function will always output to this format: MM/DD/YYYY (server accepted format)\n\n  return `${month}${separator}${day}${separator}${year}`;\n});","map":{"version":3,"sources":["/home/jonit/Personal_projects/emprego-urgente/empregourgente-backend/web/src/helpers/DateHelper.ts"],"names":["moment","appEnv","AvailableLanguages","DateHelper","date","language","ptBr","locale","format","eng","inputFormat","separator","splittedData","split","dataComponentsPosition","month","index","characters","year","day","includes","parseInt","length","rawData","splittedRawData","analyzedInputFormat","_analyzeDate"],"mappings":"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","sourcesContent":["import 'moment/locale/pt-br';\n\nimport moment from 'moment';\n\nimport { appEnv, AvailableLanguages } from '../constants/Env.constant';\n\nexport class DateHelper {\n  public static displayHumanDate = (date: string) => {\n    switch (appEnv.language) {\n      case AvailableLanguages.ptBr:\n        return moment(date)\n          .locale(\"pt-br\")\n          .format(\"ddd, DD MMM YY\");\n\n      case AvailableLanguages.eng:\n        return moment(date)\n          .locale(\"en\")\n          .format(\"ddd, MMM Do YY\");\n\n      default:\n        return moment(date)\n          .locale(\"en\")\n          .format(\"ddd, MMM Do YY\");\n    }\n  };\n\n  private static _analyzeDate = (inputFormat, separator) => {\n    const splittedData = inputFormat.split(separator);\n\n    const dataComponentsPosition = {\n      month: {\n        index: 0,\n        characters: 0\n      },\n      year: {\n        index: 0,\n        characters: 0\n      },\n      day: {\n        index: 0,\n        characters: 0\n      }\n    };\n\n    // tslint:disable-next-line: forin\n    for (const index in splittedData) {\n      if (splittedData[index].includes(\"D\")) {\n        dataComponentsPosition.day.index = parseInt(index);\n        dataComponentsPosition.day.characters = splittedData[index].length;\n      }\n      if (splittedData[index].includes(\"M\")) {\n        dataComponentsPosition.month.index = parseInt(index);\n        dataComponentsPosition.month.characters = splittedData[index].length;\n      }\n\n      if (splittedData[index].includes(\"Y\")) {\n        dataComponentsPosition.year.index = parseInt(index);\n        dataComponentsPosition.year.characters = splittedData[index].length;\n      }\n    }\n\n    return dataComponentsPosition;\n  };\n\n  public static parseDataToServerFormat = (rawData, inputFormat, separator) => {\n    const splittedRawData = rawData.split(separator);\n\n    const analyzedInputFormat = DateHelper._analyzeDate(inputFormat, separator);\n\n    const month = splittedRawData[analyzedInputFormat.month.index];\n    const day = splittedRawData[analyzedInputFormat.day.index];\n    const year = splittedRawData[analyzedInputFormat.year.index];\n\n    // this function will always output to this format: MM/DD/YYYY (server accepted format)\n\n    return `${month}${separator}${day}${separator}${year}`;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}